---- payload Matches (318 in 33 files) ----
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):              msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):          msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):            msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):              msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):            msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):            msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):          msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):              msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):            msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):        msg_ptr = (u8_t*)p->payload;
Asn1_dec.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):              msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):          msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):            msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):          msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):          msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):          msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):          msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):              msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):            msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):      msg_ptr = (u8_t*)p->payload;
Asn1_enc.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):          msg_ptr = (u8_t*)p->payload;
Dhcp.c (e:\lwip_0425\lwip-1.4.1\src\core):  dhcp->msg_in = (struct dhcp_msg *)p->payload;
Dhcp.c (e:\lwip_0425\lwip-1.4.1\src\core):  options = (u8_t*)q->payload;
Dhcp.c (e:\lwip_0425\lwip-1.4.1\src\core):      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
Dhcp.c (e:\lwip_0425\lwip-1.4.1\src\core):        options = (u8_t*)q->payload;
Dhcp.c (e:\lwip_0425\lwip-1.4.1\src\core):  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
Dhcp.c (e:\lwip_0425\lwip-1.4.1\src\core):  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
Dns.c (e:\lwip_0425\lwip-1.4.1\src\core):    hdr = (struct dns_hdr*)p->payload;
Dns.c (e:\lwip_0425\lwip-1.4.1\src\core):    pbuf_realloc(p, (u16_t)((query + SIZEOF_DNS_QUERY) - ((char*)(p->payload))));
Dns.c (e:\lwip_0425\lwip-1.4.1\src\core):  /* copy dns payload inside static buffer for processing */ 
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif): * @params p the packet to send, p->payload pointing to the (uninitialized) ethernet header
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif):  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif):  ethhdr = (struct eth_hdr *)p->payload;
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif):     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif):  ethhdr = (struct eth_hdr *)p->payload;
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif):      struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif):  ethhdr = (struct eth_hdr *)p->payload;
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif): * @param p the recevied packet, p->payload pointing to the ethernet header
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif):  /* points to packet payload, which starts with an Ethernet header */
Etharp.c (e:\lwip_0425\lwip-1.4.1\src\netif):  ethhdr = (struct eth_hdr *)p->payload;
Etharp.h (e:\lwip_0425\lwip-1.4.1\src\include\netif):/** VLAN header inserted between ethernet header and payload
Ethernetif.c (e:\lwip_0425\lwip-1.4.1\src\netif):    send data from(q->payload, q->len);
Ethernetif.c (e:\lwip_0425\lwip-1.4.1\src\netif):      read data into(q->payload, q->len);
Ethernetif.c (e:\lwip_0425\lwip-1.4.1\src\netif):  /* points to packet payload, which starts with an Ethernet header */
Ethernetif.c (e:\lwip_0425\lwip-1.4.1\src\netif):  ethhdr = p->payload;
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * @param p the icmp echo request packet, p->payload pointing to the ip header
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  iphdr = (struct ip_hdr *)p->payload;
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  type = *((u8_t *)p->payload);
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  code = *(((u8_t *)p->payload)+1);
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):      /* switch p->payload to ip header */
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):      iphdr = (struct ip_hdr *)r->payload;
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):      /* switch r->payload back to icmp header */
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):      /* restore p->payload to point to icmp header */
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    iecho = (struct icmp_echo_hdr *)p->payload;
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): *          p->payload pointing to the IP header
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): *          p->payload pointing to the IP header
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): *          p->payload pointing to the IP header
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  iphdr = (struct ip_hdr *)p->payload;
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  icmphdr = (struct icmp_echo_hdr *)q->payload;
Icmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  /* TODO: check length before accessing payload! */
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  type = ((u8_t *)p->payload)[0];
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):    iecho = p->payload;
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):    iphdr = (struct ip_hdr *)((u8_t *)p->payload - IP_HLEN);
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  iphdr = p->payload;
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  idur = q->payload;
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  SMEMCPY((u8_t *)q->payload + 8, p->payload, IP_HLEN + 8);
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  iphdr = p->payload;
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  tehdr = q->payload;
Icmp6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  SMEMCPY((u8_t *)q->payload + 8, (u8_t *)p->payload, IP_HLEN + 8);
Igmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * @param p received igmp packet, p->payload pointing to the ip header
Igmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  iphdr = (struct ip_hdr *)p->payload;
Igmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  igmp = (struct igmp_msg *)p->payload;
Igmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * @param p the packet to send (p->payload points to the data, e.g. next
Igmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):            header and p->payload points to that IP header)
Igmp.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    igmp = (struct igmp_msg *)p->payload;
Inet6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):    acc += chksum(q->payload, q->len);
Inet6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):    acc += chksum(q->payload, q->len);
Inet_chksum.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    acc += LWIP_CHKSUM(q->payload, q->len);
Inet_chksum.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    acc += LWIP_CHKSUM(q->payload, chklen);
Inet_chksum.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    acc += LWIP_CHKSUM(q->payload, q->len);
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * @param p the packet to forward (p->payload points to IP header)
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * @param p the received IP packet (p->payload points to IP header)
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  iphdr = (struct ip_hdr *)p->payload;
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    iphdr = (struct ip_hdr *)p->payload;
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):        p->payload = iphdr;
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * include an IP header and p->payload points to it instead of the data.
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * @param p the packet to send (p->payload points to the data, e.g. next
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):            header and p->payload points to that IP header)
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):      MEMCPY(p->payload, ip_options, optlen);
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):        chk_sum += ((u16_t*)p->payload)[i];
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    iphdr = (struct ip_hdr *)p->payload;
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    iphdr = (struct ip_hdr *)p->payload;
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * @param p the packet to send (p->payload points to the data, e.g. next
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):            header and p->payload points to that IP header)
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * @param p the packet to send (p->payload points to the data, e.g. next
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):            header and p->payload points to that IP header)
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4): * @param p an IP packet, p->payload pointing to the IP header
Ip.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
Ip.h (e:\lwip_0425\lwip-1.4.1\src\include\ipv6\lwip):  u16_t len;                /* payload length */
Ip6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  iphdr = p->payload;
Ip6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  iphdr = p->payload;
Ip6.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv6):  struct ip_hdr *iphdr = p->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  iprh = (struct ip_reass_helper *)ipr->p->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    iprh = (struct ip_reass_helper *)p->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  fraghdr = (struct ip_hdr*)new_p->payload; 
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  iprh = (struct ip_reass_helper*)new_p->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    iprh_tmp = (struct ip_reass_helper*)q->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):          iprh = (struct ip_reass_helper*)q->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  fraghdr = (struct ip_hdr*)p->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    fraghdr = (struct ip_hdr*)(ipr->p->payload);
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):      iprh = (struct ip_reass_helper*)r->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  iphdr = (struct ip_hdr *)rambuf->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  SMEMCPY(iphdr, p->payload, IP_HLEN);
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):  original_iphdr = (struct ip_hdr *)p->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    poff += pbuf_copy_partial(p, rambuf->payload, cop, poff);
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    iphdr = rambuf->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    iphdr = (struct ip_hdr *)rambuf->payload;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):    p->payload = (u8_t *)p->payload + poff;
Ip_frag.c (e:\lwip_0425\lwip-1.4.1\src\core\ipv4):      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
Memp_std.h (e:\lwip_0425\lwip-1.4.1\src\include\lwip): * Allocates buffers for a pbuf struct AND a payload size */
Memp_std.h (e:\lwip_0425\lwip-1.4.1\src\include\lwip):#define LWIP_PBUF_MEMPOOL(name, num, payload, desc) LWIP_MEMPOOL(name, num, (MEMP_ALIGN_SIZE(sizeof(struct pbuf)) + MEMP_ALIGN_SIZE(payload)), desc)
Memp_std.h (e:\lwip_0425\lwip-1.4.1\src\include\lwip): *     This allocates enough space for the pbuf struct and a payload.
Msg_in.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp): * @param p points to pbuf chain of SNMP message (UDP payload)
Msg_in.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp): * @param pdu_len the length of the UDP payload
Msg_in.c (e:\lwip_0425\lwip-1.4.1\src\core\snmp):    /* decoded PDU length does not equal actual payload length */
Netbuf.c (e:\lwip_0425\lwip-1.4.1\src\api):  return buf->p->payload;
Netbuf.c (e:\lwip_0425\lwip-1.4.1\src\api):  buf->p->payload = (void*)dataptr;
Netbuf.c (e:\lwip_0425\lwip-1.4.1\src\api):  *dataptr = buf->ptr->payload;
Netif.h (e:\lwip_0425\lwip-1.4.1\src\include\lwip): * @param p The packet to send (p->payload points to IP header)
Opt.h (e:\lwip_0425\lwip-1.4.1\src\include\lwip): * alignment of payload after that header. Since the header is 14 bytes long,
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param length size of the pbuf's payload
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    /* make the payload pointer point 'offset' bytes into pbuf data memory */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):                ((u8_t*)p->payload + p->len <=
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):                  ((u8_t*)p->payload + p->len <=
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):  /* pbuf references existing (non-volatile static constant) ROM payload? */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):  /* pbuf references existing (externally allocated) RAM payload? */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    p->payload = NULL;
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param length size of the pbuf's payload
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param payload_mem pointer to the buffer that is used for payload and headers,
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    p->pbuf.payload = NULL;
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core): * Adjusts the payload pointer to hide or reveal headers in the payload.
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core): * Adjusts the ->payload pointer so that space for a header
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core): * (dis)appears in the pbuf payload.
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core): * The ->payload, ->tot_len and ->len fields are adjusted.
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core): * not move the payload pointer in front of the start of the buffer.
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):  void *payload;
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):  /* remember current payload pointer */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):  payload = p->payload;
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    /* set new payload pointer */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    p->payload = (u8_t *)p->payload - header_size_increment;
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):        (void *)p->payload, (void *)(p + 1)));
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):      /* restore old payload pointer */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):      p->payload = payload;
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    /* hide a header in the payload? */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):      /* increase payload pointer */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):      p->payload = (u8_t *)p->payload - header_size_increment;
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):      /* cannot expand payload to front (yet!)
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    (void *)payload, (void *)p->payload, header_size_increment));
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param start_offset offset of p->payload where to copy the data to
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):  dst_ptr = ((char*)p->payload) + start_offset;
Pbuf.c (e:\lwip_0425\lwip-1.4.1\src\core):    return ((u8_t*)q->payload)[copy_from];
Pbuf.h (e:\lwip_0425\lwip-1.4.1\src\include\lwip):  PBUF_POOL /* pbuf payload refers to RAM */
Pbuf.h (e:\lwip_0425\lwip-1.4.1\src\include\lwip):  void *payload;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):    if((c = sio_write(pc->fd, b->payload, b->len)) != b->len) {
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):      *((u_char*)nb->payload + nb->len++) = PPP_ESCAPE;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):      *((u_char*)nb->payload + nb->len++) = c ^ PPP_TRANS;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):      *((u_char*)nb->payload + nb->len++) = c;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):    *((u_char*)pb->payload + i++) = (protocol >> 8) & 0xFF;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  *((u_char*)pb->payload + i) = protocol & 0xFF;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):    sPtr = (u_char*)p->payload;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  MEMCPY(pb->payload, s, n);
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):           /*"pppWrite[%d]: Alloc err - dropping %d:%.*H", pd, headMB->len, LWIP_MIN(headMB->len * 2, 40), headMB->payload)); */
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):                   /* "pppWrite[%d]: %d:%.*H", pd, headMB->len, LWIP_MIN(headMB->len * 2, 40), headMB->payload)); */
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  for(b = p, pl = q->payload; b != NULL; b = b->next) {
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):    MEMCPY(pl, b->payload, b->len);
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  pd = ((struct pppInputHeader *)nb->payload)->unit;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  protocol = ((struct pppInputHeader *)nb->payload)->proto;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):      PPPDEBUG(LOG_INFO, ("pppInput[%d]: drop VJ Comp in %d:%s\n", pd, nb->len, nb->payload));
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):                pd, nb->len, LWIP_MIN(nb->len * 2, 40), nb->payload));
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):          (*protp->input)(pd, nb->payload, nb->len);
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):      SMEMCPY(nb->payload, &protocol, sizeof(protocol));
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):      lcp_sprotrej(pd, nb->payload, nb->len);
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):    PPPDEBUG(LOG_INFO, ("pppDrop: %d:%.*H\n", pcrx->inHead->len, min(60, pcrx->inHead->len * 2), pcrx->inHead->payload));
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):              struct pppInputHeader *pih = nextNBuf->payload;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):          ((u_char*)pcrx->inTail->payload)[pcrx->inTail->len++] = curChar;
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  inProtocol = (((u8_t *)pb->payload)[0] << 8) | ((u8_t*)pb->payload)[1];
Ppp.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  pih = pb->payload;
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  ethhdr = (struct eth_hdr *)pb->payload;
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):    MEMCPY(&pt, (u8_t*)pb->payload + off, sizeof(pt));
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):        hunique = (u8_t*)pb->payload + off + sizeof(pt);
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):        sc = pppoe_find_softc_by_hunique((u8_t*)pb->payload + off + sizeof(pt), len, netif);
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):          ac_cookie = (u8_t*)pb->payload + off + sizeof(pt);
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):        strncpy(pppoe_error_tmp, (char*)pb->payload + off + sizeof(pt), error_len);
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  MEMCPY(shost, ((struct eth_hdr *)pb->payload)->src.addr, sizeof(shost));
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  ph = (struct pppoehdr *)pb->payload;
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  ethhdr = (struct eth_hdr *)pb->payload;
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  p = (u8_t*)pb->payload + sizeof (struct eth_hdr);
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  p = (u8_t*)pb->payload + sizeof (struct eth_hdr);
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  ethhdr = (struct eth_hdr *)pb->payload;
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  p = (u8_t*)pb->payload + sizeof (struct eth_hdr);
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  p = (u8_t*)pb->payload + sizeof (struct eth_hdr);
Ppp_oe.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  p = (u8_t*)pb->payload + sizeof(struct eth_hdr);
Raw.c (e:\lwip_0425\lwip-1.4.1\src\core):  iphdr = (struct ip_hdr *)p->payload;
Raw.c (e:\lwip_0425\lwip-1.4.1\src\core): * you actually get the IP headers), you can only specify the IP payload here.
Raw.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param p the IP payload to send
Raw.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param p the IP payload to send
Raw.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
Slipif.c (e:\lwip_0425\lwip-1.4.1\src\netif):      c = ((u8_t *)q->payload)[i];
Slipif.c (e:\lwip_0425\lwip-1.4.1\src\netif):    ((u8_t *)priv->p->payload)[priv->i] = c;
Sockets.c (e:\lwip_0425\lwip-1.4.1\src\api):        chksum = LWIP_CHKSUM_COPY(p->payload, data, short_size);
Sockets.c (e:\lwip_0425\lwip-1.4.1\src\api):      MEMCPY(p->payload, data, size);
Sockets.c (e:\lwip_0425\lwip-1.4.1\src\api):      p->payload = (void*)data;
Sockets.c (e:\lwip_0425\lwip-1.4.1\src\api):      u16_t chksum = LWIP_CHKSUM_COPY(buf.p->payload, data, short_size);
Tcpip.c (e:\lwip_0425\lwip-1.4.1\src\api): * @param p the received packet, p->payload pointing to the Ethernet header or
Tcp_in.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param p received TCP segment to process (p->payload pointing to the IP header)
Tcp_in.c (e:\lwip_0425\lwip-1.4.1\src\core):  iphdr = (struct ip_hdr *)p->payload;
Tcp_in.c (e:\lwip_0425\lwip-1.4.1\src\core):  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
Tcp_in.c (e:\lwip_0425\lwip-1.4.1\src\core):  /* remove header from payload */
Tcp_in.c (e:\lwip_0425\lwip-1.4.1\src\core):  /* Move the payload pointer in the pbuf so that it points to the
Tcp_in.c (e:\lwip_0425\lwip-1.4.1\src\core):     * 2) length of received packet is zero (i.e. no payload) 
Tcp_in.c (e:\lwip_0425\lwip-1.4.1\src\core):      /* Trimming the first edge is done by pushing the payload
Tcp_in.c (e:\lwip_0425\lwip-1.4.1\src\core):         chain. Instead, we point the ->payload pointer in the first
Tcp_in.c (e:\lwip_0425\lwip-1.4.1\src\core):         ->p->payload pointer will point to data in another pbuf.
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):/** Allocate a pbuf and create a tcphdr at p->payload, used for output
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core): * @return pbuf with p->payload being the tcp_hdr
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):    tcphdr = (struct tcp_hdr *)p->payload;
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param length size of the pbuf's payload.
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core): * @param max_length maximum usable size of payload+oversize.
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):        /* reference the non-volatile payload data */
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):        concat_p->payload = (u8_t*)arg + pos;
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):      /* reference the non-volatile payload data */
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):      p2->payload = (u8_t*)arg + pos;
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):  tcphdr = (struct tcp_hdr *)p->payload;
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):  seg->p->payload = seg->tcphdr;
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):    /* add payload checksum */
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):  tcphdr = (struct tcp_hdr *)p->payload;
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):  tcphdr = (struct tcp_hdr *)p->payload;
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):  tcphdr = (struct tcp_hdr *)p->payload;
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):    char *d = ((char *)p->payload + TCP_HLEN);
Tcp_out.c (e:\lwip_0425\lwip-1.4.1\src\core):       (unsent), seg->p->payload points to the IP header or TCP header.
Udp.c (e:\lwip_0425\lwip-1.4.1\src\core):  iphdr = (struct ip_hdr *)p->payload;
Udp.c (e:\lwip_0425\lwip-1.4.1\src\core):   * and move payload pointer to UDP header */
Udp.c (e:\lwip_0425\lwip-1.4.1\src\core):  udphdr = (struct udp_hdr *)p->payload;
Udp.c (e:\lwip_0425\lwip-1.4.1\src\core):                /* for that, move payload to IP header again */
Udp.c (e:\lwip_0425\lwip-1.4.1\src\core):                    /* move payload to UDP data */
Udp.c (e:\lwip_0425\lwip-1.4.1\src\core):          /* and move payload to UDP data again */
Udp.c (e:\lwip_0425\lwip-1.4.1\src\core):        /* move payload pointer back to ip header */
Udp.c (e:\lwip_0425\lwip-1.4.1\src\core):        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
Udp.c (e:\lwip_0425\lwip-1.4.1\src\core):  udphdr = (struct udp_hdr *)q->payload;
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  register struct ip_hdr *ip = (struct ip_hdr *)pb->payload;
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):    cp = (u_char *)pb->payload;
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):    cp = (u_char *)pb->payload;
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  ip = (struct ip_hdr *)nb->payload;
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  cp = (u_char *)n0->payload;
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  vjlen = (u_short)(cp - (u_char*)n0->payload);
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  if(LWIP_MEM_ALIGN(n0->payload) != n0->payload) {
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):    bufptr = n0->payload;
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):      MEMCPY(q->payload, bufptr, q->len);
Vj.c (e:\lwip_0425\lwip-1.4.1\src\netif\ppp):  MEMCPY(n0->payload, &cs->cs_ip, cs->cs_hlen);
